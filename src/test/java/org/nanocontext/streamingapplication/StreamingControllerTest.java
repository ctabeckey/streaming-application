package org.nanocontext.streamingapplication;


import org.mockito.Mockito;
import org.nanocontext.streamingapplication.exceptions.ResourceNotFoundException;
import org.nanocontext.streamingapplication.exceptions.ResourcePersistenceException;
import org.nanocontext.streamingapplication.exceptions.ResourceRetrievalException;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.MediaType;
import org.testng.Assert;
import org.testng.annotations.Test;

import javax.servlet.ReadListener;
import javax.servlet.ServletInputStream;
import javax.servlet.http.HttpServletRequest;
import javax.validation.Validation;
import javax.validation.Validator;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.*;

/**
 *
 */
public class StreamingControllerTest {

    /**
     * Test what should be a successful, if simple, POST
     * Note that the result can only be tested for existence and absence of an exception,
     * its content is generated by the DataSource and is tested there.
     */
    @Test
    public void testPostSuccess() throws ResourceNotFoundException, ResourcePersistenceException, ResourceRetrievalException, IOException {
        Context ctx = new Context(true, true, true, true);

        HttpServletRequest req = ctx.createServletRequest(
                HttpMethod.POST, MediaType.APPLICATION_OCTET_STREAM.toString(), null, null, true);
        ResourceMetadata actual = ctx.streamingController.post(req);
        Assert.assertNotNull(actual);
    }

    /**
     * Test what should be an unsuccessful POST, the underlying (mocked) DataSource will fail
     */
    @Test (expectedExceptions = {ResourcePersistenceException.class})
    public void testPostFailure() throws ResourceNotFoundException, ResourcePersistenceException, ResourceRetrievalException, IOException {
        Context ctx = new Context(false, true, true, true);

        HttpServletRequest req = ctx.createServletRequest(
                HttpMethod.POST, MediaType.APPLICATION_OCTET_STREAM.toString(), null, null, true);
        ctx.streamingController.post(req);
    }

    /** Test context, contains test environment and allows multithreaded testing */
    public class Context {
        private StreamingController streamingController;
        private DataSource dataSource;
        private Validator validator;

        public Context(final boolean createSuccess, final boolean readMetadataSuccess, final boolean readContentSuccess, final boolean deleteSuccess)
                throws ResourcePersistenceException, ResourceNotFoundException, ResourceRetrievalException {
            // setup the data source to succeed or fail as needed for test
            this.dataSource = Mockito.mock(DataSource.class);
            if (createSuccess)
                Mockito.when(dataSource.createResource(Mockito.any(ResourceMetadata.class), Mockito.any(InputStream.class)))
                        .thenReturn(ResourceMetadata.builder().withLength(1).withIdentifier("655321").withContentType("contenttype").build());
            else
                Mockito.when(dataSource.createResource(Mockito.any(ResourceMetadata.class), Mockito.any(InputStream.class)))
                    .thenThrow(new ResourcePersistenceException("655321"));

            if (readMetadataSuccess)
                Mockito.when(dataSource.readResourceMetadata(Mockito.anyString()))
                        .thenReturn(ResourceMetadata.builder().withLength(1).withIdentifier("655321").withContentType("contenttype").build());
            else
                Mockito.when(dataSource.readResourceMetadata(Mockito.anyString()))
                        .thenThrow(new ResourceNotFoundException("655321"));

            if (readContentSuccess)
                Mockito.when(dataSource.readResourceContent(Mockito.anyString()))
                        .thenReturn(new ByteArrayInputStream(new byte[]{0,1,2,3,4,5,6,7,8,9}));
            else
                Mockito.when(dataSource.readResourceContent(Mockito.anyString()))
                        .thenThrow(new ResourceNotFoundException("655321"));

            if (readContentSuccess)
                Mockito.when(dataSource.deleteResource(Mockito.anyString()))
                        .thenReturn(ResourceMetadata.builder().withLength(1).withIdentifier("655321").withContentType("contenttype").build());
            else
                Mockito.when(dataSource.deleteResource(Mockito.anyString()))
                        .thenThrow(new ResourceNotFoundException("655321"));

            this.validator = Validation.buildDefaultValidatorFactory().getValidator();
            streamingController = new StreamingController(dataSource, validator);
        }

        /**
         * creates a mock HttpServeltRequest with the required methods returning given values
         * @param method
         * @param contentType
         * @param length
         * @param additionalHeaders
         * @param withBody
         * @return
         * @throws IOException
         */
        public HttpServletRequest createServletRequest(
                final HttpMethod method,
                final String contentType, final Integer length, final Map<String, String> additionalHeaders,
                final boolean withBody) throws IOException {
            HttpServletRequest result = Mockito.mock(HttpServletRequest.class);

            Mockito.when(result.getMethod()).thenReturn(method.name());

            // use a Vector because it provides an enumeration method
            Vector<String> headerNames = new Vector<>();
            Mockito.when(result.getHeaderNames()).thenReturn(headerNames.elements());
            if (contentType != null) {
                headerNames.add(HttpHeaders.CONTENT_TYPE);
                Mockito.when(result.getHeader(HttpHeaders.CONTENT_TYPE)).thenReturn(contentType);
            }
            if (length != null) {
                headerNames.add(HttpHeaders.CONTENT_LENGTH);
                Mockito.when(result.getHeader(HttpHeaders.CONTENT_LENGTH)).thenReturn(length.toString());
            }
            if (additionalHeaders != null)
                for (String additionalHeaderKey : additionalHeaders.keySet()) {
                    headerNames.add(additionalHeaderKey);
                    Mockito.when(result.getHeader(additionalHeaderKey)).thenReturn(additionalHeaders.get(additionalHeaderKey));
                }

            if (withBody) {
                // create a length header consistent with the real length
                headerNames.add(HttpHeaders.CONTENT_LENGTH);
                Mockito.when(result.getHeader(HttpHeaders.CONTENT_LENGTH)).thenReturn("10");

                Mockito.when(result.getInputStream()).thenReturn(new ServletInputStream() {
                    private char[] content = new char[]{0,1,2,3,4,5,6,7,8,9};
                    private int index = 0;

                    @Override
                    public boolean isFinished() {
                        return index >= content.length;
                    }

                    @Override
                    public boolean isReady() {
                        return !isFinished();
                    }

                    @Override
                    public void setReadListener(ReadListener readListener) {
                        // no op
                    }

                    @Override
                    public int read() throws IOException {
                        return content[index++];
                    }
                });
            }

            return result;
        }
    }
}
