package org.nanocontext.streamingapplication;

import org.nanocontext.streamingapplication.exceptions.ResourceNotFoundException;
import org.nanocontext.streamingapplication.exceptions.ResourcePersistenceException;
import org.nanocontext.streamingapplication.exceptions.ResourceRetrievalException;
import org.springframework.http.MediaType;
import org.testng.Assert;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.UUID;

/**
 * Unit tests for the FileDataSource class
 */
public class FileDataSourceTest {

    /**
     * THE file length only matters because of the buffering or a zero length file
     * @return
     */
    @DataProvider
    public Object[][] createReadAndDeleteDataProvider() {
        return new Object[][] {
                {Integer.valueOf(100)},
                {Integer.valueOf(0)},
                {Integer.valueOf(10000)},
        };
    }

    /**
     * It would be preferable to test the create and read operations seperately but
     * that would require implementing much of the read functionality of the data source in the test code,
     * which then means the test code needs to be validated, etc ...
     *
     * @throws ResourcePersistenceException
     * @throws ResourceNotFoundException
     * @throws ResourceRetrievalException
     * @throws IOException
     */
    @Test(dataProvider = "createReadAndDeleteDataProvider")
    public void testCreateReadAndDeleteResource(final Integer fileLength)
            throws ResourcePersistenceException, ResourceNotFoundException, ResourceRetrievalException, IOException {
        Context ctx = new Context();

        ResourceMetadata resourceMetadata = ResourceMetadata.builder()
                .withContentType(MediaType.APPLICATION_OCTET_STREAM.toString())
                .withLength(fileLength.intValue())
                .build();

        ResourceMetadata persistedMetadata = ctx.dataSource.createResource(resourceMetadata, ctx.getInputStream(fileLength));
        Assert.assertNotNull(persistedMetadata);
        Assert.assertNotNull(persistedMetadata.getIdentifier());
        Assert.assertEquals(resourceMetadata.metadataKeys(), persistedMetadata.metadataKeys());

        Assert.assertTrue(ctx.resourceContentExists(persistedMetadata.getIdentifier()));

        ResourceMetadata retrievedMetadata = ctx.dataSource.readResourceMetadata(persistedMetadata.getIdentifier());
        Assert.assertEquals(persistedMetadata, retrievedMetadata);
        Assert.assertEquals(persistedMetadata.metadataKeys(), retrievedMetadata.metadataKeys());

        // read the content and validate its length
        // NOTE: use the persistedMetadata to get the identifier (which is generated by the data source)
        int retrievedCount = 0;
        byte[] buffy = new byte[2048];
        try (InputStream retrievedContent = ctx.dataSource.readResourceContent(persistedMetadata.getIdentifier())) {
            for (int bytesRead = retrievedContent.read(buffy); bytesRead >= 0; bytesRead = retrievedContent.read(buffy)) {
                retrievedCount += bytesRead;
            }
        }
        Assert.assertEquals(retrievedCount, fileLength.intValue());

        // delete the resource and validate that it does not exist
        ctx.dataSource.deleteResource(persistedMetadata.getIdentifier());
        Assert.assertFalse(ctx.resourceContentExists(persistedMetadata.getIdentifier()));

        ctx.cleanup();
    }

    /**
     * Test that reading the metadata of a non-existent resource results in a ResourceNotFoundException
     * @throws ResourceNotFoundException
     */
    @Test(expectedExceptions = {ResourceNotFoundException.class})
    public void testInvalidResourceMetadataRead() throws ResourceNotFoundException, ResourceRetrievalException {
        Context ctx = new Context();

        ctx.dataSource.readResourceMetadata("655321");
    }

    /**
     * Test that reading the content of a non-existent resource results in a ResourceNotFoundException
     * @throws ResourceNotFoundException
     */
    @Test(expectedExceptions = {ResourceNotFoundException.class})
    public void testInvalidResourceContentRead() throws ResourceNotFoundException, ResourceRetrievalException {
        Context ctx = new Context();

        ctx.dataSource.readResourceContent("655321");
    }

    /**
     * Test that deleting a non-existent resource results in a ResourceNotFoundException
     * @throws ResourceNotFoundException
     */
    @Test(expectedExceptions = {ResourceNotFoundException.class})
    public void testInvalidResourceDelete() throws ResourceNotFoundException {
        Context ctx = new Context();

        ctx.dataSource.deleteResource("655321");
    }

    /**
     * The test context is used to isolate test data when test instances run in parallel
     */
    public class Context {
        // the directory to create resources into
        private File rootDirectory;
        // the data source under test
        private FileDataSource dataSource;

        public Context() {
            this.rootDirectory = new File(System.getProperty("user.home"), UUID.randomUUID().toString());
            this.dataSource = new FileDataSource(this.rootDirectory);
        }

        /**
         * Creates a byte stream with the requested length
         * @param length
         * @return
         */
        public InputStream getInputStream(final int length) {
            byte[] content = new byte[length];
            for (int index=0; index < length; ++index)
                content[index] = (byte)index;
            return new ByteArrayInputStream(content);
        }

        /**
         * Simply determines if the resource exists in the expected location
         * @param identifier
         * @return
         */
        public boolean resourceContentExists(final String identifier) {
            File persistedFile = new File(rootDirectory, identifier);
            return persistedFile.exists();
        }


        /**
         * Cleanup files and directories created for test
         */
        public void cleanup() {
            this.dataSource = null;
            for (String testFileName : this.rootDirectory.list()) {
                File testFile = new File(this.rootDirectory, testFileName);
                testFile.delete();
            }
            this.rootDirectory.delete();
        }
    }

}
